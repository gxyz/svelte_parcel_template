'use strict';

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const path = require('path');

var _require = require('svelte');

const compile = _require.compile,
      preprocess = _require.preprocess;

var _require2 = require('./parcel-adapter');

const Asset = _require2.Asset;

var _require3 = require('./utils');

const sanitize = _require3.sanitize,
      capitalize = _require3.capitalize;


function makeHot(id, code, asset) {
  const hotApiRequire = path.relative(path.dirname(asset.name), require.resolve('./hot-api')).replace(/\\/g, '/');

  const replacement = `
    if (module.hot) {
      const { configure, register, reload } = require('${hotApiRequire}');

      module.hot.accept();

      if (!module.hot.data) {
        // initial load
        configure({});
        $2 = register('${id}', $2);
      } else {
        // hot update
        $2 = reload('${id}', $2);
      }
    }

    module.exports = $2;
  `;

  return code.replace(/(module.exports = ([^;]*));/, replacement);
}

class SvelteAsset extends Asset {
  constructor(name, pkg, options) {
    super(name, pkg, options);
    this.type = 'js';
  }

  generate() {
    var _this = this;

    return _asyncToGenerator(function* () {
      let compilerOptions = {
        generate: 'dom',
        format: 'cjs',
        store: true,
        css: true
      };
      let preprocessOptions;

      const fixedCompilerOptions = {
        filename: _this.relativeName,
        // The name of the constructor. Required for 'iife' and 'umd' output,
        // but otherwise mostly useful for debugging. Defaults to 'SvelteComponent'
        name: capitalize(sanitize(_this.relativeName))
      };

      let customConfig = (yield _this.getConfig(['.svelterc', 'svelte.config.js', 'package.json'])) || {};
      customConfig = customConfig.svelte || customConfig;
      if (customConfig.preprocess) {
        preprocessOptions = customConfig.preprocess;
      }

      compilerOptions = Object.assign(compilerOptions, customConfig.compilerOptions || {}, fixedCompilerOptions);

      if (preprocessOptions) {
        const preprocessed = yield preprocess(_this.contents, preprocessOptions);
        _this.contents = preprocessed.toString();
      }

      var _compile = compile(_this.contents, compilerOptions);

      let css = _compile.css,
          js = _compile.js;
      let map = js.map,
          code = js.code;


      if (process.env.NODE_ENV !== 'production') {
        code = makeHot(fixedCompilerOptions.filename, code, _this);
      }

      css = css.code;

      if (_this.options.sourceMaps) {
        map.sources = [_this.relativeName];
        map.sourcesContent = [_this.contents];
      }

      const parts = [{
        type: 'js',
        value: code,
        sourceMap: _this.options.sourceMaps ? map : undefined
      }];

      if (css) {
        parts.push({
          type: 'css',
          value: css
        });
      }

      return parts;
    })();
  }

  postProcess(generated) {
    return _asyncToGenerator(function* () {
      // Hacky fix to remove duplicate JS asset (Css HMR code)
      const filteredArr = generated.filter(function (part) {
        return part.type !== 'js';
      });
      return [generated[0]].concat(filteredArr);
    })();
  }
}

module.exports = SvelteAsset;